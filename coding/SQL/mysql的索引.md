### b-tree 索引

BTree索引是最常用的mysql数据库索引算法，因为它不仅可以被用在=,>,>=,<,<=和between这些比较操作符上，而且还可以用于like操作符，只要它的查询条件是一个不以通配符开头的常量，例如： 
`select * from user where name like 'jack%';` 
`select * from user where name like 'jac%k%';` 
如果一通配符开头，或者没有使用常量，则不会使用索引，例如： 
`select * from user where name like '%jack';` 
`select * from user where name like simply_name;`

### hash索引

Hash索引只能用于对等比较(等值比较查询)，例如=,<=>（相当于=）操作符。由于是一次定位数据，不像BTree索引需要从根节点到枝节点，最后才能访问到页节点这样多次IO访问，所以检索效率远高于BTree索引。 

但为什么我们使用BTree比使用Hash多呢？主要Hash本身由于其特殊性，也带来了很多限制和弊端： 
1. Hash索引仅仅能满足“=”,“IN”,“<=>”查询，不能使用范围查询。 
2. 联合索引中，Hash索引不能利用部分索引键查询。 
  对于联合索引中的多个列，Hash是要么全部使用，要么全部不使用，并不支持BTree支持的联合索引的最优前缀，也就是联合索引的前面一个或几个索引键进行查询时，Hash索引无法被利用。 
3. Hash索引无法避免数据的排序操作 
  由于Hash索引中存放的是经过Hash计算之后的Hash值，而且Hash值的大小关系并不一定和Hash运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算。 
4. Hash索引任何时候都不能避免表扫描 
  Hash索引是将索引键通过Hash运算之后，将Hash运算结果的Hash值和所对应的行指针信息存放于一个Hash表中，由于不同索引键存在相同Hash值，所以即使满足某个Hash键值的数据的记录条数，也无法从Hash索引中直接完成查询，还是要通过访问表中的实际数据进行比较，并得到相应的结果。 
5. Hash索引遇到大量Hash值相等的情况后性能并不一定会比BTree高 
  对于选择性比较低的索引键，如果创建Hash索引，那么将会存在大量记录指针信息存于同一个Hash值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据访问，而造成整体性能底下。