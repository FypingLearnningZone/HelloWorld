##### 1.冒泡排序 bublle sort

```python
def bubble_sort(a):
    for i in range(len(a)):
        for j in range(i + 1,len(a)):
            if a[i] > a[j]:
                a[i],a[j] = a[j],a[i]
    return a      
```

##### 2.选择排序 selection sort

```
def selection_sort(a):
    for i in range(len(a)):
        min_index = i
        for j in range(i + 1,len(a)):
            if a[j] < a[min_index]:
                min_index = j
        a[i],a[min_index] = a[min_index],a[i]
    return a
```

##### 3.归并排序 Merge sort

```python
from collections import deque

def merge_sort(lst):
    if len(lst) <= 1:
        return lst

    def merge(left, right):
        merged,left,right = [],deque(left),deque(right)
        while left and right:
            merged.append(left.popleft() if left[0] <= right[0] else right.popleft())  # deque popleft is also O(1)
        merged.extend(right if right else left)
        return merged

    middle = int(len(lst) // 2)
    left = merge_sort(lst[:middle])
    right = merge_sort(lst[middle:])
    return merge(left, right)

import random
l1 = [random.randint(1,100) for i in range(4)]
print(l1)

l2 = merge_sort(l1)
print(l2)
```



##### 4.插入排序 Insertion Sort

```python
"""
Insertion Sort
"""

array = [8, 6, 2, 3, 1, 5, 7, 4]

for Index in range(1, len(array)):  # 将第一个元素标记为已排序过的元素，所以就从1开始
    i = Index  # 当前值的索引
    temp = array[i]  # 当前值作为临时变量
    while i > 0 and temp < array[i - 1]:  # 所以大于0并且临时变量小于当前索引的前一个元素
        array[i] = array[i - 1]  # 当前索引的值等于前一个值
        i -= 1  # 把排序过的元素往左移一格
    array[i] = temp  # 当前值就等于临时变量

print(array)
```

##### 5.二分法

```python
def binary_search(list,item):
    low = 0
    high = len(list)-1
    while low <= high:
        mid = (low+high)/2
        guess = list[mid]
        if guess>item:
            high = mid-1
        elif guess<item:
            low = mid+1
        else:
            return mid
       return None

mylist = [1,3,5,7,9]
print binary_search(mylist,3)
```

####  6.台阶问题/斐波那契

一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。

```
fib = lambda n: n if n <= 2 else fib(n - 1) + fib(n - 2)
```

第二种记忆方法

```
def memo(func):
    cache = {}
    def wrap(*args):
        if args not in cache:
            cache[args] = func(*args)
        return cache[args]
    return wrap


@memo
def fib(i):
    if i < 2:
        return 1
    return fib(i-1) + fib(i-2)
```

第三种方法

```
def fib(n):
    a, b = 0, 1
    for _ in xrange(n):
        a, b = b, a + b
    return b
```

#### 7.变态台阶问题

```
一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。

fib = lambda n: n if n < 2 else 2 * fib(n - 1)
```

#### 8.快速排序

```python
def quicksort(array):
    if len(array) < 2:   # 递归出口，空数组或者只有一个元素的数组都是有序的
        return array
    else:
        pivot_index = 0    # 选择第一个元素作为主元 pivot
        pivot = array[pivot_index]
        less_part = [i for i in array[pivot_index+1:] if i <= pivot]
        great_part = [i for i in array[pivot_index+1:] if i > pivot]
        return quicksort(less_part) + [pivot] + quicksort(great_part)


def test_quicksort():
    import random
    seq = list(range(10))
    random.shuffle(seq)
    assert quicksort(seq) == sorted(seq)
```

 #### 9.汉诺塔

http://code.py40.com/algorithm/2017/06/29/python-%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98/

```
# Filename : lean001.py
# author by : www.py40.com
 
#将n个盘子从x通过y移动到z上
def move(n, x, y, z):
    if(n == 1):
        print("{}:{}->{}".format(n,x,z))
        return
    move(n-1, x, z, y)#将前n-1个盘子从x通过z移动到y上
    print("{}:{}->{}".format(n,x,z))#将第n个盘子从x移动到z上
    move(n-1, y, x, z)#将前n-1个盘子从y通过x移动到z上
    
move(3,"x","y","z");
```



