###  Python语言特性

##### 1.可变类型与不可变类型

在Python中的每个对象都可分为可变类型与不可变类型,其中 数字(int),字符串(str),元组(tuple) float是不可变类型,列表(list),字典(dict)是可变类型.

对不可变对象进行重新赋值,实际上是创建一个新的不可变对象,并将原引用指向新创建的对象
对可变类型修改后,还是指向同个内存地址，是在原处修改

##### 2.变量

变量可以理解为是内存中一个对象的"引用"

##### 3.赋值,深拷贝,浅拷贝

赋值引用 原变量与新变量指向同一个对象

**copy()** 浅拷贝 原变量与新变量是两个独立对象,但他们的子对象还是指向统一对象

​             没有拷贝子对象，所以原始数据改变，子对象改变

**copy.deepcopy ()** 深拷贝 完全拷贝父对象及其子对象,两者是相独立的

​             包含对象里面的子对象的拷贝，所以原始对象的改变不会造成深拷贝里的任何子元素的改变

1、**b = a:** 赋值引用，a 和 b 都指向同一个对象。

![img](面试.assets/1489720931-7116-4AQC6.png)

**2、b = a.copy():** 浅拷贝, a 和 b 是一个独立的对象，但他们的子对象还是指向统一对象（是引用）。

![img](面试.assets/1489720930-6827-Vtk4m.png)

**b = copy.deepcopy(a):** 深度拷贝, a 和 b 完全拷贝了父对象及其子对象，两者是完全独立的。

![img](面试.assets/1489720930-5882-BO4qO.png)

##### 4.@classmethod和@staticmethod 

python中有三种方法 类方法,静态方法和普通方法

普通方法 :需传入self参数,可访问实例属性和方法

类方法: 需传入cls参数,不可访问实例属性

静态方法: 不可访问实例属性

静态方法与类方法都可以通过类或者实例来调用。其两个的特点都是不能够调用实例属性

##### 5.自省

自省是指这种能力：检查某些事物以确定它是什么、它知道什么以及它能做什么

​                                   是指在运行时来判断一个对象的类型的能力

##### 6.列表推导式,字典推导式,集合推导式

```
variable = [out_exp for out_exp in input_list if out_exp == 2]
```

```
{v: k for k, v in some_dict.items()}
```

```
squared = {x**2 for x in [1, 1, 2]}
```

##### 7.python中的单下划线和双下划线
```
__init__ 是一种命名约定方式,python内部名称,用以区别用户自定义的的命名,防止冲突
_foo 用来指定变量私有,不能用from modules import *导入,其他和公有变量一样访问
__foo 解析器用_classname__foo 来代替这个名字,以区别其他类中相同的名称,无法像其他公有变量一样访问,通过通过 对象名._类名__xxx这样的方式可以访问
```
##### 8.字符串格式化 %和.format

```
"my name is %s" % name 
```

这样写可能不会出什么问题,但如果传递的name是一个元组,就会抛出一个TypeError异常

```
"my name is %s" % (name,)
```

这样写就可以了

而用.format就会不会出现这种问题

```
"my name is {}".format(name) 
```

##### 9.生成器和迭代器
将列表生成式中[]改成() 之后数据结构是否改变？ 答案：是，从列表变为生成器

```
>>> L = [x*x for x in range(10)]
>>> L
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
>>> g = (x*x for x in range(10))
>>> g
<generator object <genexpr> at 0x0000028F8B774200>
```

通过列表生成式，可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含百万元素的列表，不仅是占用很大的内存空间，如：我们只需要访问前面的几个元素，后面大部分元素所占的空间都是浪费的。因此，没有必要创建完整的列表（节省大量内存空间）。在Python中，我们可以采用生成器：边循环，边计算的机制—>generator

##### 10.AOP面向切面编程,与装饰器

装饰器的作用就是为已经存在的对象添加额外的的功能

##### 11.鸭子类型

“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”

我们并不关心对象是什么类型，到底是不是鸭子，只关心行为。

比如在python中，有很多file-like的东西，比如StringIO,GzipFile,socket。它们有很多相同的方法，我们把它们当作文件使用。

又比如list.extend()方法中,我们并不关心它的参数是不是list,只要它是可迭代的,所以它的参数可以是list/tuple/dict/字符串/生成器等.

鸭子类型在动态语言中经常使用，非常灵活，使得python不想java那样专门去弄一大堆的设计模式。

##### 12.python重载

在静态语言中，方法重载是希望类可以以统一的方式处理不同类型的数据提供了可能。多个同名函数同时存在，具有不同的参数个数/类型，重载是一个类中多态性的一种表现.

在静态语言中，方法重载是希望类可以以统一的方式处理不同类型的数据提供了可能。多个同名函数同时存在，具有不同的参数个数/类型，重载是一个类中多态性的一种表现.

##### 13.新式类和旧式类

新式类很早在2.2就出现了,所以旧式类完全是兼容的问题,Python3里的类全部都是新式类.这里有一个MRO问题可以了解下(新式类是广度优先,旧式类是深度优先),<Python核心编程>里讲的也很多.

> 一个旧式类的深度优先的例子

```
class A():
    def foo1(self):
        print "A"
class B(A):
    def foo2(self):
        pass
class C(A):
    def foo1(self):
        print "C"
class D(B, C):
    pass

d = D()
d.foo1()

# A
```

按照经典类的查找顺序从左到右深度优先的规则，在访问d.foo1()的时候,D这个类是没有的..那么往上查找,先找到B,里面没有,深度优先,访问A,找到了foo1(),所以这时候调用的是A的foo1()，从而导致C重写的foo1()被绕过

在python2中,定义类的时候继承object就为新式类

在python中,默认为新式类

##### 14.```__new__和__init__```

1. `__new__`是一个静态方法,而`__init__`是一个实例方法.
2. `__new__`方法会返回一个创建的实例,而`__init__`什么都不返回.
3. 只有在`__new__`返回一个cls的实例时后面的`__init__`才能被调用.
4. 当创建一个新实例时调用`__new__`,初始化一个实例时用`__init__`.

 ##### 15.python作用域

一个变量的作用域是被赋值的位置决定的

依次由内而外寻找,现在自己的作用域查找,找不到,再去上级查找,如果找不到就抛出异常 报错

```python
#终极版作用域
 
name = "lzl"
 
def f1():
    print(name)
 
def f2():
    name = "eric"
    f1()
 
f2()
#输出lzl

#终极版作用域
 
name = "lzl"
 
def f1():
    print(name)
 
def f2():
    name = "eric"
    return f1
 
ret = f2()
ret()
 
#输出：lzl
```

在执行f1()时,f1()与f2()没有关系,f1()向上一级查找,即全局变量``` name="lzl"```

##### 16.range和xrange

在python2.x中range创建的是一个list,而xrange生成的是一个生成器.每次调用返回其中的一个值

在python3.x中没有xrange,range从list变为一个生成器

##### 17.python3中的除法,取余,向上向下取整,四舍五入

 ###### 除法的运算

‘/’ 无论是否整除返回的都是 *float* ，暂且叫它精确除法 
例如 ： 10/5，的到的结果是 2.0 
‘//’无论是否整除返回的都是 *int* ，而且是去尾整除 
例如 ：5//2，得到的结果是 2

| name     | func         | 返回值 |
| -------- | ------------ | ------ |
| 向上取整 | math.ceil()  | int    |
| 向下取整 | math.floor() | int    |
| 四舍五入 | round()      | int    |

##### 18.read,readline,readlines

- read 读取整个文件
- readline 读取下一行,使用生成器方法
- readlines 读取整个文件到一个迭代器,供我们遍历

##### 19.python的is和==

is 比较的是地址

== 对比的是值

##### 20.python的垃圾回收机制

python GC主要使用 引用计数 （reference counting）来跟踪和回收垃圾,在引用计数的基础上,用标记-清除  （mark and sweep）解决容器对象可能产生的循环引用问题,通过 分代回收 （generation collection）以空间换时间的方法来提高垃圾的回收效率

##### 1. 引用计数

   PyObject 是每个对象必有的内容,其中ob_refcnt 就作为引用计数,当对象的引用增加时,对象的ob_refcnt 就会增加,当对象的引用被删除时,对象的引用计数就会减少,当对象的引用计数为0时,对象就会被回收.

   

   优点:

   1. 简单
   2. 实时性

   缺点:

   1. 维护计数引用消耗资源
   2. 循环引用

   

##### 2. 标记-清除

   分为两个阶段, 阶段一 GC为活动的对象打上标记,阶段二 清除那些没有标记的 非活动对象

   等到没有空闲内存的时候从寄存器和程序栈上的引用出发，遍历以对象为节点、以引用为边构成的图，把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没标记的对象释放。

   

##### 3. 分代回收

   分代回收的整体思想是：将系统中的所有内存块根据其存活时间划分为不同的集合，每个集合就成为一个“代”，垃圾收集频率随着“代”的存活时间的增大而减小，存活时间通常利用经过几次垃圾回收来度量。

   Python默认定义了三代对象集合，索引数越大，对象存活时间越长。

   举例： 当某些内存块M经过了3次垃圾收集的清洗之后还存活时，我们就将内存块M划到一个集合A中去，而新分配的内存都划分到集合B中去。当垃圾收集开始工作时，大多数情况都只对集合B进行垃圾回收，而对集合A进行垃圾回收要隔相当长一段时间后才进行，这就使得垃圾收集机制需要处理的内存少了，效率自然就提高了。在这个过程中，集合B中的某些内存块由于存活时间长而会被转移到集合A中，当然，集合A中实际上也存在一些垃圾，这些垃圾的回收会因为这种分代的机制而被延迟。

##### 21.闭包

- 闭包避免了使用全局变量
- 闭包 使即使脱离了函数本身的作用范围，局部变量还可以被访问得到

##### 22.python2.x与3.x

##### 23.GIL线程全局锁

线程全局锁(Global Interpreter Lock),即Python为了保证线程安全而采取的独立线程运行的限制,说白了就是一个核只能在同一时间运行一个线程.**对于io密集型任务，python的多线程起到作用，但对于cpu密集型任务，python的多线程几乎占不到任何优势，还有可能因为争夺资源而变慢。**

见[Python 最难的问题](http://www.oschina.net/translate/pythons-hardest-problem)

解决办法就是多进程和下面的协程(协程也只是单CPU,但是能减小切换代价提升性能).

##### 24.协程

简单点说协程是进程和线程的升级版,进程和线程都面临着内核态和用户态的切换问题而耗费许多切换时间,而协程就是用户自己控制切换的时机,不再需要陷入系统的内核态.

Python里最常见的yield就是协程的思想!可以查看第九个问题.

##### 25.lamada

```
#if 条件为真的时候返回if前面内容，否则返回0
exp1= lambda x:x+1 if  2==1 else 0
```

##### 26.

ADT: Abstract Data Type，抽象数据类型，我们在组合已有的数据结构来实现一种新的数据类型， ADT 定义了类型的数据和操作。

###### 实现 ADT 我们应该注意什么？

- 如何选用恰当的数据结构作为存储？
- 选取的数据结构能否满足 ADT 的功能需求
- 实现效率如何？

 ##### 26

`_X`和 `__all__`这种形式的变量名，可以防止客户端使用 from *导入模块时，把其中的变量名复制出去。 也可以使用 `__all__`指定可以复制出去的变量名

##### 27 编码 解码

![sm.ms](python语言特性.assets/582c111e3fa73.png)

- 把 UTF-8 编码表示的字符串 'xxx' 转换为 Unicode 字符串 u'xxx' 用 `decode('utf-8')` 方法：

```
>>> '中文'.decode('utf-8')
u'\u4e2d\u6587'
```

- 把 u'xxx' 转换为 UTF-8 编码的 'xxx' 用 `encode('utf-8')` 方法：

```
>>> u'中文'.encode('utf-8')
'\xe4\xb8\xad\xe6\x96\x87'
```

###### Reference

- [taizilongxu/interview_python](https://github.com/taizilongxu/interview_python#9-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8)
- [python之禅](https://foofish.net/categories.html)