###  Python语言特性

##### 1.可变类型与不可变类型

在Python中的每个对象都可分为可变类型与不可变类型,其中 数字,字符串,元祖 是不可变类型,列表,字典是可变类型.

对不可变对象进行重新赋值,实际上是创建一个新的不可变对象,并将原引用指向新创建的对象
对可变类型修改后,还是指向同个内存地址，是在原处修改

##### 2.变量

变量可以理解为是内存中一个对象的"引用"

##### 3.赋值,深拷贝,浅拷贝

赋值引用 原变量与新变量指向同一个对象

**copy()** 浅拷贝 原变量与新变量是两个独立对象,但他们的子对象还是指向统一对象

​             没有拷贝子对象，所以原始数据改变，子对象改变

**copy.deepcopy ()** 深拷贝 完全拷贝父对象及其子对象,两者是相独立的

​             包含对象里面的子对象的拷贝，所以原始对象的改变不会造成深拷贝里的任何子元素的改变

1、**b = a:** 赋值引用，a 和 b 都指向同一个对象。

![img](面试.assets/1489720931-7116-4AQC6.png)

**2、b = a.copy():** 浅拷贝, a 和 b 是一个独立的对象，但他们的子对象还是指向统一对象（是引用）。

![img](面试.assets/1489720930-6827-Vtk4m.png)

**b = copy.deepcopy(a):** 深度拷贝, a 和 b 完全拷贝了父对象及其子对象，两者是完全独立的。

![img](面试.assets/1489720930-5882-BO4qO.png)

##### 4.@classmethod和@staticmethod 

python中有三种方法 类方法,静态方法和普通方法

普通方法 :需传入self参数,可访问实例属性和方法

类方法: 需传入cls参数,不可访问实例属性

静态方法: 不可访问实例属性

静态方法与类方法都可以通过类或者实例来调用。其两个的特点都是不能够调用实例属性

##### 5.自省

自省是指这种能力：检查某些事物以确定它是什么、它知道什么以及它能做什么

​                                   是指在运行时来判断一个对象的类型的能力

##### 6.列表推导式,字典推导式,集合推导式

```
variable = [out_exp for out_exp in input_list if out_exp == 2]
```

```
{v: k for k, v in some_dict.items()}
```

```
squared = {x**2 for x in [1, 1, 2]}
```

##### 7.python中的单下划线和双下划线
```
__init__ 是一种命名约定方式,python内部名称,用以区别用户自定义的的命名,防止冲突
_foo 用来指定变量私有,不能用from modules import *导入,其他和公有变量一样访问
__foo 解析器用_classname__foo 来代替这个名字,以区别其他类中相同的名称,无法像其他公有变量一样访问,通过通过 对象名._类名__xxx这样的方式可以访问
```
##### 8.字符串格式化 %和.format

```
"my name is %s" % name 
```

这样写可能不会出什么问题,但如果传递的name是一个元组,就会抛出一个TypeError异常

```
"my name is %s" % (name,)
```

这样写就可以了

而用.format就会不会出现这种问题

```
"my name is {}".format(name) 
```

##### 9.生成器和迭代器
将列表生成式中[]改成() 之后数据结构是否改变？ 答案：是，从列表变为生成器

```
>>> L = [x*x for x in range(10)]
>>> L
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
>>> g = (x*x for x in range(10))
>>> g
<generator object <genexpr> at 0x0000028F8B774200>
```

通过列表生成式，可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含百万元素的列表，不仅是占用很大的内存空间，如：我们只需要访问前面的几个元素，后面大部分元素所占的空间都是浪费的。因此，没有必要创建完整的列表（节省大量内存空间）。在Python中，我们可以采用生成器：边循环，边计算的机制—>generator

##### 10.AOP面向切面编程,与装饰器

装饰器的作用就是为已经存在的对象添加额外的的功能

##### 11.鸭子类型

“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”

我们并不关心对象是什么类型，到底是不是鸭子，只关心行为。

比如在python中，有很多file-like的东西，比如StringIO,GzipFile,socket。它们有很多相同的方法，我们把它们当作文件使用。

又比如list.extend()方法中,我们并不关心它的参数是不是list,只要它是可迭代的,所以它的参数可以是list/tuple/dict/字符串/生成器等.

鸭子类型在动态语言中经常使用，非常灵活，使得python不想java那样专门去弄一大堆的设计模式。

##### 12.python重载

在静态语言中，方法重载是希望类可以以统一的方式处理不同类型的数据提供了可能。多个同名函数同时存在，具有不同的参数个数/类型，重载是一个类中多态性的一种表现.

在静态语言中，方法重载是希望类可以以统一的方式处理不同类型的数据提供了可能。多个同名函数同时存在，具有不同的参数个数/类型，重载是一个类中多态性的一种表现.

##### 13.新式类和旧式类

新式类很早在2.2就出现了,所以旧式类完全是兼容的问题,Python3里的类全部都是新式类.这里有一个MRO问题可以了解下(新式类是广度优先,旧式类是深度优先),<Python核心编程>里讲的也很多.

> 一个旧式类的深度优先的例子

```
class A():
    def foo1(self):
        print "A"
class B(A):
    def foo2(self):
        pass
class C(A):
    def foo1(self):
        print "C"
class D(B, C):
    pass

d = D()
d.foo1()

# A
```

按照经典类的查找顺序从左到右深度优先的规则，在访问d.foo1()的时候,D这个类是没有的..那么往上查找,先找到B,里面没有,深度优先,访问A,找到了foo1(),所以这时候调用的是A的foo1()，从而导致C重写的foo1()被绕过

在python2中,定义类的时候继承object就为新式类

在python中,默认为新式类

##### 14.```__new__和__init__```

1. `__new__`是一个静态方法,而`__init__`是一个实例方法.
2. `__new__`方法会返回一个创建的实例,而`__init__`什么都不返回.
3. 只有在`__new__`返回一个cls的实例时后面的`__init__`才能被调用.
4. 当创建一个新实例时调用`__new__`,初始化一个实例时用`__init__`.

 ##### 15.python作用域

一个变量的作用域是被赋值的位置决定的

依次由内而外寻找,现在自己的作用域查找,找不到,再去上级查找,如果找不到就抛出异常 报错

##### 16.range和xrange

在python2.x中range创建的是一个list,而xrange生成的是一个生成器.每次调用返回其中的一个值

在python3.x中没有xrange,range从list变为一个生成器

##### 17.python3中的除法,取余,向上向下取整,四舍五入

 ###### 除法的运算

‘/’ 无论是否整除返回的都是 *float* ，暂且叫它精确除法 
例如 ： 10/5，的到的结果是 2.0 
‘//’无论是否整除返回的都是 *int* ，而且是去尾整除 
例如 ：5//2，得到的结果是 2

| name     | func         | 返回值 |
| -------- | ------------ | ------ |
| 向上取整 | math.ceil()  | int    |
| 向下取整 | math.floor() | int    |
| 四舍五入 | round()      | int    |

##### 18.read,readline,readlines

- read 读取整个文件
- readline 读取下一行,使用生成器方法
- readlines 读取整个文件到一个迭代器,供我们遍历

##### 19.python的is和==

is 比较的是地址

== 对比的是值

##### 20.